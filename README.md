# DynaTest Dynamic Testing

[![Build Status](https://travis-ci.org/mvysny/dynatest.svg?branch=master)](https://travis-ci.org/mvysny/dynatest)
[![GitHub tag](https://img.shields.io/github/tag/mvysny/dynatest.svg)](https://github.com/mvysny/dynatest/tags)

Traditional JUnit/TestNG approach is to have a bunch of test classes with `@Test`-annotated methods. That's not bad per se,
but it would seem as if the ultimate JUnit's goal was that the test collection must be *pre-known* - computable by static-analyzing class files alone,
without running any test generator code whatsoever. With such approach, 
the possibilities to create tests dynamically (e.g. creating a reusable test suite) are severely limited. I believe this requirement is not only
useless in modern programming,
it also *reduces the possibilities* of how to structure test code and *promotes bad practices*:

* You simply can't create a parametrized test suite class as a component, instantiating it with various parameters and running it as needed,
  with parameters supplied in the call site.
* Annotations are weak - they don't have the full computative power of a proper imperative programming language; attempts to use annotations to
  express any non-trivial logic leads to annotation overuse and that leads to horrible constructs and [annotatiomania](http://annotatiomania.com/).
* Reuse of test suites is only possible by the means of inheritance (having a base class with tests, and a bunch of classes
  extending that base class, parametrizing it with constructors). That leads to deep inheritance hierarchies, which typically lead to spaghetti code.
  Reusing code as components typically leads to much better separated code with clear boundaries.
* Even worse than inheritance, it is possible to "reuse" test suites by the means of interface mixins. That's a whole new level
  of inheritance hell.

Think of Maven (with `pom.xml` with no computative power) versus Gradle - a build script with tasks
generated by a full-blown programming language. We need to throw away the old ways of configuration-using-static declarations,
and embrace testing structures created programmatically.

**Note**: I've seen horrendous Gradle scripts with complicated logic which caused me to long for Maven. That's definitely a despicable practice.
A good test suite should strive for the test structure to be clearly visible in the test file, with bits of logic here and there, mostly for
computing parameters for a reusable test battery and for disabling tests according to the environment.
Dynamically generating tests via a sequence is most probably a very bad idea.

## Disadvantages

It's not just unicorns:

* There is no clear distinction between the code that *creates* tests (calls the `test()` method), and
  the *testing* code itself (blocks inside of `test()` method). However, there is a ton of difference:
  those two code bases run at completely different time. Furthermore Kotlin allows to share variables
  freely between those two code bases, which may create a really dangerous code which fails in mysterious ways.
  That's magic which must be removed. See [Issue #1](https://github.com/mvysny/dynatest/issues/1) for more details.

## Design principles

Ideally, the testing framework should follow these items:

* Promote component-oriented programming. You should be able to create a test suite as a component,
  and simply include that test suite anywhere you see fit.
* Dissuade from abominable programming techniques like inheritance and annotatiomania.
* Allow creating tests dynamically, in a fucking `for` loop if necessary.
* Put the programmer in charge and allow him to use the full palette of software practices, in order
  to create well-maintainable test code.
* With great power comes great responsibility. Don't make the test structure generation code more complex
  than anything else in your project. Keep it simple.

What this framework is not:

* BDD. What BDD strives for is to describe a behavior of an app. What it really does is that it provides
  a really lousy, obfuscated and computationally weak way of writing test programs. There is no good. For bad, head to
  [JBehave](http://jbehave.org/). To experience a real horror, head to [Robot Framework](http://robotframework.org/).
* Spec. What spec strives for is to describe a specification of an app. What it really does is that it provides
  a lousy way of writing test programs. If you want spec, use [Spek](http://spekframework.org/).

## Example

Code example of the [CalculatorTest.kt](src/test/kotlin/com/github/mvysny/dynatest/CalculatorTest.kt):

```kotlin
class Calculator {
    fun plusOne(i: Int) = i + 1
    fun close() {}
}

/**
 * A test case.
 */
class CalculatorTest : DynaTest({

    /**
     * Top-level test.
     */
    test("calculator instantiation test") {
        Calculator()
    }

    // you can have as many groups as you like, and you can nest them
    // 'group' has no semantic definition, you are free to assign one as you need
    group("tests the plusOne() function") {

        // demo of the very simple test
        test("one plusOne") {
            expect(2) { Calculator().plusOne(1) }
        }

        // nested group
        group("positive numbers") {
            // you can even create a reusable test battery, call it from anywhere and use any parameters you like.
            calculatorBattery(0..10)
            calculatorBattery(100..110)
        }

        group("negative numbers") {
            calculatorBattery(-50..-40)
        }
    }
})

/**
 * Demonstrates a reusable test battery which can be called repeatedly and parametrized.
 * @receiver all tests+groups do not run immediately, but instead they register themselves to this group; they are run later on
 * when launched by JUnit5
 * @param range parametrized battery demo
 */
fun DynaNodeGroup.calculatorBattery(range: IntRange) {
    require(!range.isEmpty())

    group("plusOne on $range") {
        lateinit var c: Calculator

        // analogous to @Before in JUnit4, or @BeforeEach in JUnit5
        beforeEach { c = Calculator() }
        // analogous to @After in JUnit4, or @AfterEach in JUnit5
        afterEach { c.close() }

        // we can even generate test cases in a loop
        for (i in range) {
            test("plusOne($i) == ${i + 1}") {
                expect(i + 1) { c.plusOne(i) }
            }
        }
    }
}
```

Running this in your IDE will produce:

![DynaTest CalculatorTest screenshot](images/dynatest.png)

## Current drawbacks

* Weak IDE (Intellij) integration:
  * "Rerun failed tests" always runs all tests
  * Impossible to run single test only (right-clicking on the test name doesn't offer such option)

There's a [IDEA-169198](https://youtrack.jetbrains.com/issue/IDEA-169198) bug report for Intellij, so let's see.

## Using DynaTest in your projects

DynaTest sports its own TestEngine which ignores any JUnit5 tests and only runs `DynaTest` tests. As a first step,
add the test dependency on this library to your `build.gradle` file:

```groovy
repositories {
    maven { url "https://dl.bintray.com/mvysny/github" }
}
dependencies {
    testCompile("com.github.mvysny.dynatest:dynatest:x.y")
}
```

> Note: check the tag number on the top for the newest version

DynaTest will transitively include JUnit5's core.

If you are using older Gradle 4.5.x or earlier which does not have native support for JUnit5, to actually
run the tests you will need to add the [junit5-gradle-consumer](https://github.com/junit-team/junit5-samples/tree/r5.0.3/junit5-gradle-consumer)
plugin to your build script. Please see the plugin's documentation for details.

If you are using Gradle 4.6 or later, JUnit5 support is built-in; all you need to enable it is to insert this into your `build.gradle` file:

```groovy
test {
    useJUnitPlatform()
}
```

(more on Gradle's JUnit5 support here: [Gradle JUnit5 support](https://docs.gradle.org/4.6-rc-1/release-notes.html#junit-5-support))

If you want to run JUnit5 tests along the DynaTest tests as well, you can run both DynaTest test engine along with JUnit5 Jupiter engine
(which will only run JUnit5 tests and will ignore DynaTest tests):

```groovy
dependencies {
    testRuntime("org.junit.jupiter:junit-jupiter-engine:5.1.0")
}
```

## Patterns

### Conditional tests

Simply call the `test()` function only when the condition applies. For example:

```kotlin
class NativesTest : DynaTest({
    if (OS.isLinux()) {
        test("linux-based test") {
            // run tests only on Linux.
        }
    }
})
```

### Reusable test battery

You can simply create a (possibly parametrized) function which runs in the context of the
`DynaNodeGroup`. That allows the function to create test groups and tests as necessary:

```kotlin
fun DynaNodeGroup.layoutTestBattery(clazz: Class<out ComponentContainer>) {
    group("tests for ${clazz.simpleName}") {
        lateinit var layout: ComponentContainer
        beforeEach { layout = clazz.newInstance() }
        test("Adding a component will make the count go to 1") {
            layout.addComponent(Label("Hello World"))
            expect(1) { layout.getComponentCount() }
        }
    }
}

class LayoutTest : DynaTest({
    layoutTestBattery(VerticalLayout::class.java)
    layoutTestBattery(HorizontalLayout::class.java)
    layoutTestBattery(CssLayout::class.java)
    layoutTestBattery(FlexLayout::class.java)
})
```

### Plugging in into the test life-cycle

Say that you want to mock the database and clean it before and after every test. Very easy:

```kotlin
fun DynaNodeGroup.usingDatabase() {

    beforeGroup {
        VaadinOnKotlin.dataSourceConfig.apply {
            minimumIdle = 0
            maximumPoolSize = 30
            this.jdbcUrl = "jdbc:h2:mem:test;DB_CLOSE_DELAY=-1"
            this.username = "sa"
            this.password = ""
        }
        Sql2oVOKPlugin().init()
        db {
            con.createQuery("""create table if not exists Test (
                id bigint primary key auto_increment,
                name varchar not null,
                age integer not null,
                dateOfBirth date,
                created timestamp,
                alive boolean,
                maritalStatus varchar
                 )""").executeUpdate()
        }
    }

    afterGroup {
        Sql2oVOKPlugin().destroy()
    }

    fun clearDatabase() = Person.deleteAll()
    beforeEach { clearDatabase() }
    afterEach { clearDatabase() }
}

class EntityDataProviderTest : DynaTest({

    usingDatabase()

    test("noEntitiesTest") {
        val ds = Person.dataProvider
        expect(0) { ds.size(Query()) }
        expect(false) { ds.isInMemory }
        expectList() { ds.getAll() }
    }
})
```

This sample is taken from Vaadin-on-Kotlin [EntityDataProviderTest.kt](https://github.com/mvysny/vaadin-on-kotlin/blob/master/vok-framework-sql2o/src/test/kotlin/com/github/vok/framework/sql2o/vaadin/EntityDataProviderTest.kt) file,
which is somewhat complex.

Your typical test will look like this:

```kotlin
class SomeOtherEntityTest : DynaTest({

    usingDatabase()
    
    test("calculating average age") {
        db { 
            for (i in 0..10) { Person(age = i).save() }
        }
        expect(5) { Person.averageAge() }
    }
})
```

Head to [vok-orm](https://github.com/mvysny/vok-orm) on how to use the database in this fashion from your app.

### Real-world Web App Example

A testing bootstrap in your application will be a lot simpler. See the following example taken from
the [Vaadin Kotlin PWA Demo](https://github.com/mvysny/vaadin-kotlin-pwa):

```kotlin
class MainViewTest: DynaTest({
    beforeGroup { Bootstrap().contextInitialized(null) }
    afterGroup { Bootstrap().contextDestroyed(null) }
    beforeEach { MockVaadin.setup(autoDiscoverViews("com.vaadin.pwademo")) }
    beforeEach { Task.deleteAll() }
    afterEach { Task.deleteAll() }

    test("add a task") {
        UI.getCurrent().navigateTo("")
        _get<TextField> { caption = "Title:" } .value = "New Task"
        _get<Button> { caption = "Add" } ._click()
        expectList("New Task") { Task.findAll().map { it.title } }
        expect(1) { _get<Grid<*>>().dataProvider._size() }
    }
})
```

